---
title: "Shiny Burguers"
subtitle: "Crea experiencias interactivas con datosüìäüöÄ"
lang: "es"
toc: true
comments: false
code-copy: true
format:
  html:
    mermaid:
      theme: forest
bibliography: references.bib
---

---

![](../img/shiny_burgers.png)


## Estructura B√°sica de una Aplicaci√≥n Shiny

Imaginemos que estamos en un restaurante llamado **Shiny Burgers** üçî. Este lugar, como cualquier buen restaurante, tiene dos √°reas principales: el sal√≥n principal y la cocina.

El sal√≥n principal, donde se atiende a los clientes, es nuestra `UI` (interfaz de usuario). Aqu√≠, los meseros, que representan los `Inputs` y `Outputs`, son los encargados de interactuar directamente con los clientes. Los `Inputs` son los meseros que **reciben las √≥rdenes** de los clientes, como campos de texto, botones y men√∫s desplegables. Estos meseros llevan las √≥rdenes a la cocina.

La cocina es el `server`, el lugar donde se preparan las √≥rdenes. Dentro de la cocina, los `renderers` üë®üèª‚Äçüç≥ son los cocineros. Estos cocineros toman las √≥rdenes que les llevan los meseros (Inputs)‚úçüèª, preparan los alimentos siguiendo recetas y procesos espec√≠ficos, y una vez que la comida est√° lista, la entregan a los meseros (Outputs) üíÅüèª‚Äç‚ôÇÔ∏è.

Volviendo a nuestra analog√≠a, cuando un cliente llega a **Shiny Burgers**, interact√∫a con los meseros (Inputs) en el sal√≥n principal (UI). El cliente revisa el men√∫ y hace su pedido. Los meseros (Inputs) llevan este pedido a la cocina (server), donde los renderers (cocineros) trabajan en preparar el pedido. Los `renderers` siguen las recetas y procesos necesarios para transformar los ingredientes (datos) en un plato delicioso.

Una vez que la comida est√° lista, los `renderers` (cocineros) entregan el plato a los meseros (Outputs), quienes se lo llevan de vuelta al cliente en el sal√≥n principal (UI). De esta manera, el cliente recibe su pedido preparado.


![](../img/meseros.png)

## Primera app

```{r, eval=FALSE}

library(shiny)

ui <- fluidPage(
  textInput(
    inputId = "nombre",
    label = "Ingrese su nombre"
  ),
  textOutput(
    outputId = "saludo"
  )
)

server <- function(input, output, session) {
  
  output$saludo <- renderText({
    paste0("Hola",input$nombre, "!")
  })
  
}

shinyApp(ui, server)
```


En este primer ejemplo, tenemos un `textInput`. Eso quiere decir que nuestro usuario va a poder ingresar un texto a la aplicaci√≥n. Y por otro lado tenemos un `textOutput`, o una salida de texto. Quiere decir que en alg√∫n momento de la aplicaci√≥n, nosotros vamos a mostrarle un texto al usuario.

```{r, eval=FALSE}
ui <- fluidPage(
  textInput(
    inputId = "nombre", # nombre unico para el input
    label = "Ingrese su nombre"
  ),
  textOutput(
    outputId = "saludo" # nombre unico para el output
  )
)
```


Como dijimos antes, todo esto se cocina en el lado del servidor. Es por eso que vemos que el `output`, llamado **saludo**, es en el `server` en donde lo creamos.

Algo importante e indispensable: siempre un `output` va a estar asociado a un tipo espec√≠fico de `render`. De la misma forma que hay cocineros que son buenos haciendo sushi, otros son buenos haciendo hamburguesas, otros son buenos haciendo sopa. Tenemos `renders` que se especializan para cada uno de los tipos de platos que se pueden preparar, o en este caso los tipos de `outputs` que podemos tener.

```{r, eval=FALSE}
# usamos renderText porque el output es de tipo Texto
output$saludo <- renderText({
    paste0("Hola",input$nombre, "!")
  })
```

En este caso, como lo que queremos preparar es un `textOutput`, vamos a llamar a la funci√≥n especializada, que ser√≠a `renderText`. Si ejecutamos este c√≥digo, vamos a ver que tenemos una peque√±a aplicaci√≥n, que cuando una persona ingresa un texto, en este caso su nombre, la salida que se genera en el `textOutput` es ‚Äúhola‚Äù y el nombre que se ingres√≥.

## Vamos a practicarüèãüèª‚Äç‚ôÄÔ∏è

1. **Crear un nuevo script de Shiny**: En este script, estableceremos la estructura b√°sica de una aplicaci√≥n Shiny. No se preocupen por trabajar con dos archivos como les han ense√±ado; comenzaremos con un solo archivo para simplificar el proceso. No hay ninguna diferencia y ser√° m√°s f√°cil para todos nosotros.

2.	**Crear una aplicaci√≥n b√°sica**: La aplicaci√≥n consistir√° en un Numeric Input, donde el usuario podr√° ingresar un n√∫mero, y un Output de tipo texto. En el servidor, tomaremos el n√∫mero ingresado por el usuario, le sumaremos 7 y lo presentaremos en pantalla a trav√©s del Text Output que creamos anteriormente.

3.	**Tiempo estimado**: Disponemos de 5 a 10 minutos para completar este ejercicio. Trabajaremos en grupos.

---


## Veamos nuevos Inputs

Tenemos diferentes tipos de inputs. En el siguiente enlace, que es la [Galer√≠a Oficial Shiny](https://shiny.posit.co/r/gallery/widgets/widget-gallery/), podr√°s ver los tipos de inputs y outputs disponibles. Es importante recordar que diferentes tipos de `inputs` requieren diferentes `par√°metros`.

Por ejemplo:

+ **`Select Input`:** Es ideal para seleccionar entre m√∫ltiples categor√≠as. Los par√°metros necesarios son:
    + Label: La etiqueta que se mostrar√° al usuario.
    + Choices: Las opciones disponibles para seleccionar.
    + Selected: La opci√≥n que se mostrar√° por defecto al abrir la aplicaci√≥n.
+ **`Slider Input`**: Permite seleccionar uno o dos n√∫meros. Los par√°metros necesarios son:
    + Min: El valor m√≠nimo.
    + Max: El valor m√°ximo.
    + Value: El valor o valores seleccionados. Puede ser un √∫nico n√∫mero o un vector con dos n√∫meros para especificar un rango.


```{r, eval=FALSE}
library(shiny)
library(datos)
library(tidyverse)

datos <- pinguinos

ui <- fluidPage(
  selectInput(
    inputId = "especie",
    label = "Seleccione una espacie",
    choices = c("Adelia",  "Pap√∫a",   "Barbijo"),
    selected = "Adelia"
  ),
  sliderInput(
    inputId = "anio",
    label = "Seleccione un a√±o",
    min = 2007,
    max = 2009,
    value = 2008
  ),
  plotOutput(
    outputId = "grafico"
  )
)

server <- function(input, output, session) {
  
  output$grafico <- renderPlot({
    
    df <- datos |> 
      filter(especie == input$especie, anio == input$anio)
    
    ggplot(
      data = df,
      mapping = aes(
        x = alto_pico_mm
      )
    ) +
      geom_histogram(color = "white") +
      theme_minimal()
    
  })
  
}

shinyApp(ui, server)
```

### Interfaz de usuario. (UI)

En nuestra aplicaci√≥n, primero definimos los inputs y outputs. Un input ser√° la especie del ping√ºino y el otro ser√° el a√±o de la observaci√≥n.

Creamos un `selectInput` con los nombres de las especies disponibles en el dataset, permitiendo al usuario elegir una especie espec√≠fica.

Tambi√©n a√±adimos un `sliderInput` para seleccionar el a√±o de la observaci√≥n, con un rango de 2007 a 2009.

Finalmente, definimos un `plotOutput`, inicialmente vac√≠o, donde se mostrar√° el gr√°fico generado por la aplicaci√≥n.


```{r, eval=FALSE}
selectInput(
    inputId = "especie",
    label = "Seleccione una espacie",
    choices = c("Adelia",  "Pap√∫a",   "Barbijo"),
    selected = "Adelia"
  ),
  sliderInput(
    inputId = "anio",
    label = "Seleccione un a√±o",
    min = 2007,
    max = 2009,
    value = 2008
  ),
  plotOutput(
    outputId = "grafico"
  )
```

### Server

Del lado del servidor, aparece un concepto clave: **la reactividad.**‚ö°Ô∏è Imagina que haces un pedido en un restaurante y luego necesitas modificarlo porque olvidaste mencionar que eres al√©rgico al tomate.üçÖ El mesero corre a la cocina para hacer el cambio.

La reactividad en Shiny funciona de manera similar; autom√°ticamente, cuando los `inputs` cambian, se env√≠an se√±ales al servidor para que vuelva a preparar desde cero lo que se mostrar√° en los `outputs`. En nuestro caso, necesitamos que la tabla de ping√ºinos se `filtre` para mostrar solo los ping√ºinos de la `especie` seleccionada y para el `a√±o seleccionado`. Para hacerlo, llamamos directamente a `input$especie` y `input$anio`.

```{r, eval=FALSE}
output$grafico <- renderPlot({
    
    df <- datos |> 
      filter(especie == input$especie, anio == input$anio)
    
    ggplot(
      data = df,
      mapping = aes(
        x = alto_pico_mm
      )
    ) +
      geom_histogram(color = "white") +
      theme_minimal()
    
  })
```


Es crucial entender que cuando un `render` usa informaci√≥n de los `inputs`, se crea una dependencia entre ellos, y cualquier cambio en un `input` har√° que se genere una nueva salida. 

Una vez tenemos esta tabla filtrada, podemos usar `ggplot2` para crear nuestro gr√°fico de `histograma`. Es importante que la √∫ltima l√≠nea dentro de un `renderPlot` sea la que genera el gr√°fico, y lo mismo aplica para todos los otros tipos de `renders`.

---

## Vamos a practicar üèãüèª‚Äç‚ôÄÔ∏è

1.	**Definir la estructura de nuestra app con Shiny:**
En este script, estableceremos la estructura b√°sica de una aplicaci√≥n Shiny. No se preocupen por trabajar con dos archivos como les han ense√±ado; comenzaremos con un solo archivo para simplificar el proceso. No hay ninguna diferencia y ser√° m√°s f√°cil para todos nosotros.

2.	**Crear los inputs:**
    + Crear un select input para elegir la especie de ping√ºino.
    + Crear un slider input para seleccionar el a√±o de observaci√≥n (2007-2009).
    + Crear un slider input para ajustar el tama√±o de los puntos en el gr√°fico.

3.	**Generar un gr√°fico de dispersi√≥n:**
	‚Ä¢	Filtrar la tabla de ping√ºinos seg√∫n la especie y el a√±o seleccionados.
	‚Ä¢	Generar el gr√°fico de dispersi√≥n utilizando `ggplot2`, mostrando en el eje Y el largo del pico y en el eje X el ancho del pico. Ajustar el tama√±o de los puntos seg√∫n el valor seleccionado.

**Tiempo estimado:** Disponemos de 10 a 15 minutos para completar este ejercicio. Trabajaremos en grupos.‚è∞

## Layouts

Ahora que tenemos claros los conceptos m√°s b√°sicos de c√≥mo trabajar con Shiny, veamos c√≥mo podemos organizar la interfaz. Las formas en las que distribuimos o repartimos los elementos de la interfaz se suelen denominar como layouts. Hay muchos tipos de layouts y podr√≠amos incluso inventar nuestros propios si lo deseamos. Sin embargo, para los t√©rminos de este taller, vamos a utilizar solamente uno, que es probablemente el m√°s simple y tambi√©n el m√°s utilizado: el `SidebarLayout.`

El `SidebarLayout` nos permite tener, en un lado, normalmente a la izquierda, los controladores o todos los inputs de nuestra aplicaci√≥n. En el lado derecho, tenemos un panel m√°s grande y principal donde se mostrar√°n los resultados, como tablas o gr√°ficos.


```{r, eval=FALSE}
library(shiny)
library(datos)
library(tidyverse)

datos <- pinguinos

ui <- fluidPage(
  titlePanel("An√°lisis de Ping√ºinos"),
  sidebarLayout(
    sidebarPanel(
      selectInput(
        inputId = "especie",
        label = "Seleccione una especie",
        choices = c("Adelia", "Pap√∫a", "Barbijo"),
        selected = "Adelia"
      ),
      sliderInput(
        inputId = "anio",
        label = "Seleccione un a√±o",
        min = 2007,
        max = 2009,
        value = 2008
      )
    ),
    mainPanel(
      plotOutput(
        outputId = "grafico"
      )
    )
  )
)

server <- function(input, output, session) {
  
  output$grafico <- renderPlot({
    df <- datos |> 
      filter(especie == input$especie, anio == input$anio)
    
    ggplot(
      data = df,
      mapping = aes(
        x = alto_pico_mm
      )
    ) +
      geom_histogram(color = "white") +
      theme_minimal()
  })
  
}

shinyApp(ui, server)
```


El `SidebarLayout` en Shiny se utiliza para organizar la interfaz de usuario en dos secciones: una barra lateral y un panel principal.

+ **SidebarPanel**: Este panel se encuentra dentro del `SidebarLayout` y contiene todos los elementos de control, como los `inputs` de la aplicaci√≥n (por ejemplo, `selectInput`, `sliderInput`). Es donde el usuario interact√∫a para ingresar datos o hacer selecciones.

+ **MainPanel**: Tambi√©n dentro del `SidebarLayout`, este panel se usa para mostrar los resultados de la aplicaci√≥n, como gr√°ficos, tablas y otros `outputs`. Es el √°rea principal donde se visualizan los datos procesados.


```{r, eval=FALSE}
ui <- fluidPage(
  titlePanel("An√°lisis de Ping√ºinos"),
  sidebarLayout(
    sidebarPanel(
      selectInput(
        inputId = "especie",
        label = "Seleccione una especie",
        choices = c("Adelia", "Pap√∫a", "Barbijo"),
        selected = "Adelia"
      ),
      sliderInput(
        inputId = "anio",
        label = "Seleccione un a√±o",
        min = 2007,
        max = 2009,
        value = 2008
      )
    ),
    mainPanel(
      plotOutput(
        outputId = "grafico"
      )
    )
  )
)
```

## Mapa IPS

Ahora que ya podemos crear aplicaciones Shiny simples, vamos a crear una aplicaci√≥n un poco m√°s grande y compleja. Utilizaremos datos geoespaciales de Costa Rica y nuestro objetivo ser√° que el usuario pueda seleccionar una provincia o varias provincias, y nosotros le mostraremos en un mapa de cantones diferentes indicadores que se utilizan para el c√°lculo del √≠ndice de progreso social en Costa Rica.

+ [Descargar datos aqu√≠](https://share.aprendetidyverse.com/s/demo_shiny_geo)

```{r, eval=FALSE}
library(shiny)
library(sf)
library(tidyverse)

mapa <- read_sf("clases/cantones_ips_cr.geojson")

ui <- fluidPage(
  titlePanel("An√°lisis de Ping√ºinos"),
  sidebarLayout(
    sidebarPanel(
      selectInput(
        inputId = "provincia",
        label = "Seleccione una provincia",
        choices = unique(mapa$provincia),
        selected =  unique(mapa$provincia)[1]
      ),
      selectInput(
        inputId = "variable",
        label = "Seleccione una variable",
        choices = colnames(mapa)[-c(1:5)],
        selected =  colnames(mapa)[6]
      )
    ),
    mainPanel(
      plotOutput(
        outputId = "grafico"
      )
    )
  )
)

server <- function(input, output, session) {
  
  output$grafico <- renderPlot({
    
    df <- mapa |> 
      select(var = input$variable)
    
    ggplot(
      data = df,
      mapping = aes(
        fill = var
      )
    ) +
      geom_sf(color = "white") +
      scale_fill_viridis_c() +
      theme_minimal()
    
  })
  
}

shinyApp(ui, server)
```

---

Muchas gracias a todos por su participaci√≥n y dedicaci√≥n durante este taller. S√© que puede ser cansado y a veces frustrante cuando las cosas no salen perfectas a la primera. Pero recuerden, la clave est√° en la pr√°ctica constante. Cuanto m√°s practiquen, m√°s dominar√°n estas herramientas y t√©cnicas.

## ü§î Espacio para Preguntas 

Ahora abrimos un espacio de 20 minutos para preguntas y consultas. Tom√©monos un minuto para contestar cada pregunta, as√≠ podemos cubrir todas sus dudas. Estoy aqu√≠ para ayudarles, as√≠ que no duden en preguntar lo que necesiten.

Nuevamente, gracias por su esfuerzo y entusiasmo. Estoy aqu√≠ para apoyarlos en su aprendizaje. ¬°Sigamos aprendiendo juntos!


---

> ¬øQuieres aprender m√°s y mejorar tus habilidades con datos? üìä Inscr√≠bete en nuestros cursos en vivo. üñ•Ô∏è Nos adaptamos a tu horario con sesiones personalizadas. ‚è∞ Aprender√°s de un instructor c√≥mo sacar el m√°ximo provecho a esta herramienta para trabajar con datos en R. üìà [Inscr√≠bete aqu√≠](https://aprendetidyverse.com/courses/fundamentos_R.html).


